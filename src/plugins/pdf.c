/* pdf.c
 *
 * Add support for cracking PDF files
 * Copyright (C) 2013 Dhiru Kholia <dhiru at openwall.com>
 *
 * pdf.c uses code from Sumatra PDF and MuPDF which are under GPL
 *
 * hashkill - a hash cracking tool
 * Copyright (C) 2010 Milen Rangelov <gat3way@gat3way.eu>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */

#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <alloca.h>
#include <sys/types.h>
#include <openssl/sha.h>
#include <openssl/md5.h>
#include <fcntl.h>
#include <stdint.h>
#include <stdlib.h>
#include "plugin.h"
#include "rc4.c"
#include "pdfcrack_md5.c"
#include "err.h"
#include "hashinterface.h"


char myfilename[255];
int vectorsize;

static struct custom_salt {
	int V;
	int R;
	int P;
	char encrypt_metadata;
	unsigned char u[127];
	unsigned char o[127];
	unsigned char ue[32];
	unsigned char oe[32];
	unsigned char id[32];
	int length;
	int length_id;
	int length_u;
	int length_o;
	int length_ue;
	int length_oe;
} cs;


char *hash_plugin_summary(void)
{
	return ("pdf \tpdf passphrase plugin");
}


char *hash_plugin_detailed(void)
{
	return ("pdf - pdf passphrase plugin\n"
	    "------------------------------------------------\n"
	    "Use this module to crack pdf files\n"
	    "Input should be a pdf hash file (specified with -f) generated by pdf2john.py utility\n"
	    "\nAuthor: Dhiru Kholia <dhiru at openwall.com>\n");
}


hash_stat hash_plugin_parse_hash(char *hashline, char *filename)
{
	char *ctcopy;
	char *keeptr;
	char *p;
	
	if (hashline==NULL) return hash_err;
	if (strlen(hashline)<32) return hash_err;
	ctcopy  = strdup(hashline);
	keeptr  = ctcopy;
	p = strtok(ctcopy, ":");
	strcpy(myfilename, p);
	p = strtok(NULL, "*");
	cs.V = atoi(p);
	p = strtok(NULL, "*");
	cs.R = atoi(p);
	p = strtok(NULL, "*");
	cs.length = atoi(p);
	p = strtok(NULL, "*");
	cs.P = atoi(p);
	p = strtok(NULL, "*");
	cs.encrypt_metadata = atoi(p);
	p = strtok(NULL, "*");
	cs.length_id = atoi(p);
	p = strtok(NULL, "*");
	hex2str((char *) cs.id, p, cs.length_id);
	p = strtok(NULL, "*");
	cs.length_u = atoi(p);
	p = strtok(NULL, "*");
	hex2str((char *) cs.u, p, cs.length_u);
	p = strtok(NULL, "*");
	cs.length_o = atoi(p);
	p = strtok(NULL, "*");
	hex2str((char *) cs.o, p, cs.length_o);

	free(keeptr);

	(void) hash_add_username(myfilename);
	(void) hash_add_hash("pdf file    \0", 0);
	(void) hash_add_salt("123");
	(void) hash_add_salt2("                              ");
	return hash_ok;
}

static const unsigned char padding[32] = {
	0x28, 0xbf, 0x4e, 0x5e, 0x4e, 0x75, 0x8a, 0x41,
	0x64, 0x00, 0x4e, 0x56, 0xff, 0xfa, 0x01, 0x08,
	0x2e, 0x2e, 0x00, 0xb6, 0xd0, 0x68, 0x3e, 0x80,
	0x2f, 0x0c, 0xa9, 0xfe, 0x64, 0x53, 0x69, 0x7a
};

/* Compute an encryption key (PDF 1.7 algorithm 3.2) */
static void pdf_compute_encryption_key(unsigned char *password, int pwlen, unsigned char *key)
{
	unsigned char buf[32];
	unsigned int p;
	int n;
	MD5_CTX md5;

	n = cs.length / 8;

	/* Step 1 - copy and pad password string */
	if (pwlen > 32)
		pwlen = 32;
	memcpy(buf, password, pwlen);
	memcpy(buf + pwlen, padding, 32 - pwlen);

	/* Step 2 - init md5 and pass value of step 1 */
	MD5_Init(&md5);
	MD5_Update(&md5, buf, 32);

	/* Step 3 - pass O value */
	MD5_Update(&md5, cs.o, 32);

	/* Step 4 - pass P value as unsigned int, low-order byte first */
	p = (unsigned int) cs.P;
	buf[0] = (p) & 0xFF;
	buf[1] = (p >> 8) & 0xFF;
	buf[2] = (p >> 16) & 0xFF;
	buf[3] = (p >> 24) & 0xFF;
	MD5_Update(&md5, buf, 4);

	/* Step 5 - pass first element of ID array */
	MD5_Update(&md5, cs.id, cs.length_id);

	/* Step 6 (revision 4 or greater) - if metadata is not encrypted pass 0xFFFFFFFF */
	if (cs.R >= 4) {
		if (!cs.encrypt_metadata) {
			buf[0] = 0xFF;
			buf[1] = 0xFF;
			buf[2] = 0xFF;
			buf[3] = 0xFF;
			MD5_Update(&md5, buf, 4);
		}
	}

	/* Step 7 - finish the hash */
	MD5_Final(buf, &md5);

	/* Step 8 (revision 3 or greater) - do some voodoo 50 times */
	if (cs.R >= 3) {
		/* for (i = 0; i < 50; i++)
		   {
		   MD5_Init(&md5);
		   MD5_Update(&md5, buf, n);
		   MD5_Final(buf, &md5);
		   } */
		md5_50(buf);
	}
	/* Step 9 - the key is the first 'n' bytes of the result */
	memcpy(key, buf, n);
}

/* Compute an encryption key (PDF 1.7 ExtensionLevel 3 algorithm 3.2a) */

static void
pdf_compute_encryption_key_r5(unsigned char *password, int pwlen, int ownerkey, unsigned char *validationkey)
{
	unsigned char buffer[128 + 8 + 48];
	SHA256_CTX sha256;

	/* Step 2 - truncate UTF-8 password to 127 characters */

	if (pwlen > 127)
		pwlen = 127;

	/* Step 3/4 - test password against owner/user key and compute encryption key */

	memcpy(buffer, password, pwlen);
	if (ownerkey) {
		memcpy(buffer + pwlen, cs.o + 32, 8);
		memcpy(buffer + pwlen + 8, cs.u, 48);
	} else
		memcpy(buffer + pwlen, cs.u + 32, 8);

	SHA256_Init(&sha256);
	SHA256_Update(&sha256, buffer, pwlen + 8 + (ownerkey ? 48 : 0));
	SHA256_Final(validationkey, &sha256);
}

/* SumatraPDF: support crypt version 5 revision 6 */
/*
 * Compute an encryption key (PDF 1.7 ExtensionLevel 8 algorithm 3.2b)
 * http://esec-lab.sogeti.com/post/The-undocumented-password-validation-algorithm-of-Adobe-Reader-X
 */

static void
pdf_compute_hardened_hash_r6(unsigned char *password, int pwlen, unsigned char salt[8],
    unsigned char *ownerkey, unsigned char hash[32])
{
	unsigned char data[(128 + 64 + 48) * 64];
	unsigned char block[64];
	int block_size = 32;
	int data_len = 0;
	int i, j, sum;

	SHA256_CTX sha256;
	SHA512_CTX sha384;
	SHA512_CTX sha512;
	AES_KEY aes;

	/* Step 1: calculate initial data block */
	SHA256_Init(&sha256);
	SHA256_Update(&sha256, password, pwlen);
	SHA256_Update(&sha256, salt, 8);
	if (ownerkey)
		SHA256_Update(&sha256, ownerkey, 48);
	SHA256_Final(block, &sha256);

	for (i = 0; i < 64 || i < data[data_len * 64 - 1] + 32; i++) {
		/* Step 2: repeat password and data block 64 times */
		memcpy(data, password, pwlen);
		memcpy(data + pwlen, block, block_size);
		// ownerkey is always NULL
		// memcpy(data + pwlen + block_size, ownerkey, ownerkey ? 48 : 0);
		data_len = pwlen + block_size + (ownerkey ? 48 : 0);
		for (j = 1; j < 64; j++)
			memcpy(data + j * data_len, data, data_len);

		/* Step 3: encrypt data using data block as key and iv */
		AES_set_encrypt_key(block, 128, &aes);
		// aes_crypt_cbc(&aes, AES_ENCRYPT, data_len * 64, block + 16, data, data);
		AES_cbc_encrypt(data, data, data_len * 64, &aes, block + 16, AES_ENCRYPT);

		/* Step 4: determine SHA-2 hash size for this round */
		for (j = 0, sum = 0; j < 16; j++)
			sum += data[j];

		/* Step 5: calculate data block for next round */
		block_size = 32 + (sum % 3) * 16;
		switch (block_size) {
		case 32:
			SHA256_Init(&sha256);
			SHA256_Update(&sha256, data, data_len * 64);
			SHA256_Final(block, &sha256);
			break;
		case 48:
			SHA384_Init(&sha384);
			SHA384_Update(&sha384, data, data_len * 64);
			SHA384_Final(block, &sha384);
			break;
		case 64:
			SHA512_Init(&sha512);
			SHA512_Update(&sha512, data, data_len * 64);
			SHA512_Final(block, &sha512);
			break;
		}
	}

	memset(data, 0, sizeof(data));
	memcpy(hash, block, 32);
}

/* Computing the user password (PDF 1.7 algorithm 3.4 and 3.5) */

static void pdf_compute_user_password(unsigned char *password, unsigned char *output)
{

	int pwlen = strlen((char *) password);
	unsigned char key[128];

	if (cs.R == 2) {
		RC4_KEY arc4;
		int n;
		n = cs.length / 8;
		pdf_compute_encryption_key(password, pwlen, key);
		RC4_set_key(&arc4, n, key);
		RC4(&arc4, 32, padding, output);
	}

	if (cs.R == 3 || cs.R == 4) {
		unsigned char xor[32];
		unsigned char digest[16];
		MD5_CTX md5;
		RC4_KEY arc4;
		int i, x, n;
		n = cs.length / 8;
		pdf_compute_encryption_key(password, pwlen, key);
		MD5_Init(&md5);
		MD5_Update(&md5, (char *) padding, 32);
		MD5_Update(&md5, cs.id, cs.length_id);
		MD5_Final(digest, &md5);
		RC4_set_key(&arc4, n, key);
		RC4(&arc4, 16, digest, output);
		for (x = 1; x <= 19; x++) {
			for (i = 0; i < n; i++)
				xor[i] = key[i] ^ x;
			RC4_set_key(&arc4, n, xor);
			RC4(&arc4, 16, output, output);
		}
		memcpy(output + 16, padding, 16);
	}
	if (cs.R == 5) {
		pdf_compute_encryption_key_r5(password, pwlen, 0, output);
	}

	/* SumatraPDF: support crypt version 5 revision 6 */
	if (cs.R == 6)
		pdf_compute_hardened_hash_r6(password, pwlen, cs.u + 32, NULL, output);

}


hash_stat hash_plugin_check_hash(const char *hash, const char *password[VECTORSIZE], const char *salt,
    char *salt2[VECTORSIZE], const char *username, int *num, int threadid)
{
	char *buf[VECTORSIZE];

	int a;

	for (a = 0; a < vectorsize; a++) {
		buf[a] = alloca(32);
	}
	for (a = 0; a < vectorsize; a++) {
		pdf_compute_user_password((unsigned char*)password[a], (unsigned char*)buf[a]);
		if (cs.R == 3 || cs.R == 4)
			if (memcmp(buf[a], cs.u, 16) == 0) {
				*num = a;
				return hash_ok;
			}
		if (cs.R == 2 || cs.R == 5 || cs.R == 6)
			if (memcmp(buf[a], cs.u, 32) == 0) {
				*num = a;
				return hash_ok;
			}
	}

	return hash_err;
}


int hash_plugin_hash_length(void)
{
	return 16;
}

int hash_plugin_is_raw(void)
{
	return 0;
}

int hash_plugin_is_special(void)
{
	return 0;
}

void get_vector_size(int size)
{
	vectorsize = size;
}

int get_salt_size(void)
{
	return 4;
}
